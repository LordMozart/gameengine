<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D FPS Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 10px;
      height: 10px;
      background: red;
      transform: translate(-50%, -50%);
      border-radius: 50%;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <div id="crosshair"></div>
  <div id="hud">Health: <span id="playerHealth">100</span> | Score: <span id="score">0</span></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
  <script>
    // Basic setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // HUD elements
    const playerHealthElement = document.getElementById("playerHealth");
    const scoreElement = document.getElementById("score");

    // Player properties
    let playerHealth = 100;
    let score = 0;

    // Movement controls
    const keys = {};
    let isJumping = false;
    let velocityY = 0;
    const gravity = -0.01;

    document.addEventListener('keydown', (e) => keys[e.key] = true);
    document.addEventListener('keyup', (e) => keys[e.key] = false);

    const playerSpeed = 0.1;
    const jumpSpeed = 0.3;

    // Handle player movement
    function handlePlayerMovement() {
      const forward = new THREE.Vector3();
      const right = new THREE.Vector3();

      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();

      right.crossVectors(forward, camera.up).normalize();

      const newPosition = camera.position.clone();

      if (keys['w']) newPosition.addScaledVector(forward, playerSpeed);
      if (keys['s']) newPosition.addScaledVector(forward, -playerSpeed);
      if (keys['a']) newPosition.addScaledVector(right, -playerSpeed);
      if (keys['d']) newPosition.addScaledVector(right, playerSpeed);

      // Jumping
      if (keys[' '] && !isJumping) {
        isJumping = true;
        velocityY = jumpSpeed;
      }

      // Apply gravity
      velocityY += gravity;
      newPosition.y += velocityY;

      // Collision with the ground
      if (newPosition.y < 1) {
        newPosition.y = 1;
        velocityY = 0;
        isJumping = false;
      }

      // Keep player within boundaries
      newPosition.clamp(
        new THREE.Vector3(-50, 1, -50),
        new THREE.Vector3(50, 10, 50)
      );

      camera.position.copy(newPosition);
    }

    // Pointer lock for mouse control
    document.body.addEventListener('click', () => {
      document.body.requestPointerLock();
    });

    let yaw = 0;
    document.addEventListener('mousemove', (event) => {
      if (document.pointerLockElement === document.body) {
        yaw -= event.movementX * 0.002; // Left-right rotation (yaw)
        camera.rotation.set(0, yaw, 0); // Only apply yaw (left-right rotation)
      }
    });

    // Skybox setup with single image
    const skyTexture = new THREE.TextureLoader().load('garfield.png');
    skyTexture.mapping = THREE.EquirectangularRefractionMapping;
    scene.background = skyTexture;

    // Add green floor
    const floorGeometry = new THREE.PlaneGeometry(200, 200);
    const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = - Math.PI / 2;
    scene.add(floor);

    // Box setup
    const boxTexture = new THREE.TextureLoader().load('garfield.png'); // Replace with your box image
    const boxes = [];
    for (let i = 0; i < 10; i++) {
      const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
      const boxMaterial = new THREE.MeshBasicMaterial({ map: boxTexture });
      const box = new THREE.Mesh(boxGeometry, boxMaterial);
      box.position.set(
        Math.random() * 80 - 40,
        1,
        Math.random() * 80 - 40
      );
      scene.add(box);
      boxes.push(box);
    }

    // Detect collisions with boxes
    function checkCollisions() {
      const playerBox = new THREE.Box3().setFromObject(camera);
      boxes.forEach((box) => {
        const boxBoundingBox = new THREE.Box3().setFromObject(box);
        if (playerBox.intersectsBox(boxBoundingBox)) {
          // Collision detected, stop player movement in that direction
          camera.position.sub(camera.position.clone().sub(box.position).multiplyScalar(0.1));
        }
      });
    }

    // Enemy management
    const enemies = [];
    const enemySpeed = 0.05;

    function spawnEnemy() {
      const enemyGeometry = new THREE.BoxGeometry(1, 1, 1);
      const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
      enemy.position.set(
        Math.random() * 40 - 20,
        1,
        Math.random() * 40 - 20
      );
      enemy.health = 50;
      enemies.push(enemy);
      scene.add(enemy);
    }

    setInterval(spawnEnemy, 3000); // Spawn an enemy every 3 seconds

    function updateEnemies() {
      enemies.forEach((enemy, index) => {
        const direction = new THREE.Vector3();
        direction.subVectors(camera.position, enemy.position).normalize();
        enemy.position.addScaledVector(direction, enemySpeed);

        if (enemy.position.distanceTo(camera.position) < 1) {
          playerHealth -= 10;
          playerHealthElement.textContent = playerHealth;
          if (playerHealth <= 0) alert("Game Over!");
          scene.remove(enemy);
          enemies.splice(index, 1);
        }
      });
    }

    // Shooting with cooldown
    let canShoot = true;

    document.addEventListener('click', () => {
      if (!canShoot) return;

      canShoot = false;
      setTimeout(() => canShoot = true, 200); // 0.2-second cooldown

      const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
      const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
      bullet.position.copy(camera.position);
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      bullet.velocity = direction.multiplyScalar(0.5);
      bullet.startPosition = camera.position.clone();
      bullets.push(bullet);
      scene.add(bullet);
    });

    const bullets = [];
    function updateBullets() {
      bullets.forEach((bullet, index) => {
        bullet.position.add(bullet.velocity);

        if (bullet.position.distanceTo(bullet.startPosition) > 50) {
          scene.remove(bullet);
          bullets.splice(index, 1);
        }

        enemies.forEach((enemy, enemyIndex) => {
          if (bullet.position.distanceTo(enemy.position) < 1) {
            enemy.health -= 25;
            if (enemy.health <= 0) {
              scene.remove(enemy);
              enemies.splice(enemyIndex, 1);
              score += 10;
              scoreElement.textContent = score;
            }
            scene.remove(bullet);
            bullets.splice(index, 1);
          }
        });
      });
    }

    // Game Loop
    function animate() {
      requestAnimationFrame(animate);
      handlePlayerMovement();
      checkCollisions();
      updateEnemies();
      updateBullets();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>

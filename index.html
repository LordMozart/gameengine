<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D FPS Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 10px;
      height: 10px;
      background: red;
      transform: translate(-50%, -50%);
      border-radius: 50%;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <div id="crosshair"></div>
  <div id="hud">Health: <span id="playerHealth">100</span> | Score: <span id="score">0</span></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
  <script>
    // Basic setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // HUD elements
    const playerHealthElement = document.getElementById("playerHealth");
    const scoreElement = document.getElementById("score");

    // Player properties
    let playerHealth = 100;
    let score = 0;

    // Movement controls
    const keys = {};
    let isJumping = false;
    let velocityY = 0;
    const gravity = -0.01;

    document.addEventListener('keydown', (e) => keys[e.key] = true);
    document.addEventListener('keyup', (e) => keys[e.key] = false);

    const playerSpeed = 0.1;
    const jumpSpeed = 0.3;

    // Handle player movement
    function handlePlayerMovement() {
      const forward = new THREE.Vector3();
      const right = new THREE.Vector3();

      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();

      right.crossVectors(forward, camera.up).normalize();

      const newPosition = camera.position.clone();

      if (keys['w']) newPosition.addScaledVector(forward, playerSpeed);
      if (keys['s']) newPosition.addScaledVector(forward, -playerSpeed);
      if (keys['a']) newPosition.addScaledVector(right, -playerSpeed);
      if (keys['d']) newPosition.addScaledVector(right, playerSpeed);

      // Jumping
      if (keys[' '] && !isJumping) {
        isJumping = true;
        velocityY = jumpSpeed;
      }

      // Apply gravity
      velocityY += gravity;
      newPosition.y += velocityY;

      // Collision with the ground or parkour boxes
      parkourBoxes.forEach((box) => {
        const boxBoundingBox = new THREE.Box3().setFromObject(box);
        if (newPosition.y <= box.position.y + box.scale.y / 2 && boxBoundingBox.containsPoint(newPosition)) {
          newPosition.y = box.position.y + box.scale.y / 2;
          velocityY = 0;
          isJumping = false;
        }
      });

      if (newPosition.y < 1) {
        newPosition.y = 1;
        velocityY = 0;
        isJumping = false;
      }

      // Keep player within boundaries
      newPosition.clamp(
        new THREE.Vector3(-50, 1, -50),
        new THREE.Vector3(50, 10, 50)
      );

      camera.position.copy(newPosition);
    }

    // Pointer lock for mouse control
    document.body.addEventListener('click', () => {
      document.body.requestPointerLock();
    });

    let yaw = 0;
    document.addEventListener('mousemove', (event) => {
      if (document.pointerLockElement === document.body) {
        yaw -= event.movementX * 0.002; // Left-right rotation (yaw)
        camera.rotation.set(0, yaw, 0); // Only apply yaw (left-right rotation)
      }
    });

    // Skybox setup with single image
    const skyTexture = new THREE.TextureLoader().load('sky.jpg'); // Replace with your panoramic image
    skyTexture.mapping = THREE.EquirectangularRefractionMapping;
    scene.background = skyTexture;

    // Add ground texture
    const floorGeometry = new THREE.PlaneGeometry(200, 200);
    const floorTexture = new THREE.TextureLoader().load('ground.jpg'); // Replace with your ground texture image
    const floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = - Math.PI / 2;
    scene.add(floor);

    // Parkour Box setup with random sizes and positions
    const parkourBoxes = [];
    const boxTexture = new THREE.TextureLoader().load('garfield.png'); // Replace with your box image

    for (let i = 0; i < 10; i++) {
      const boxGeometry = new THREE.BoxGeometry(Math.random() * 5 + 1, Math.random() * 3 + 1, Math.random() * 5 + 1); // Random size
      const boxMaterial = new THREE.MeshBasicMaterial({ map: boxTexture });
      const box = new THREE.Mesh(boxGeometry, boxMaterial);
      box.position.set(
        Math.random() * 80 - 40,
        Math.random() * 5 + 1, // Ensure they float above the ground
        Math.random() * 80 - 40
      );
      scene.add(box);
      parkourBoxes.push(box);
    }

    // Bullet management
    const bullets = [];
    function updateBullets() {
      bullets.forEach((bullet, index) => {
        bullet.position.add(bullet.velocity);

        // Remove bullets after 50 units or when they hit a box
        if (bullet.position.distanceTo(bullet.startPosition) > 50) {
          scene.remove(bullet);
          bullets.splice(index, 1);
        }

        parkourBoxes.forEach((box, boxIndex) => {
          const boxBoundingBox = new THREE.Box3().setFromObject(box);
          if (boxBoundingBox.containsPoint(bullet.position)) {
            // Bullet hits the box
            scene.remove(bullet);
            bullets.splice(index, 1);
          }
        });
      });
    }

    // Shooting with cooldown
    let canShoot = true;

    document.addEventListener('click', () => {
      if (!canShoot) return;

      canShoot = false;
      setTimeout(() => canShoot = true, 200); // 0.2-second cooldown

      const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
      const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
      bullet.position.copy(camera.position);
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      bullet.velocity = direction.multiplyScalar(0.5);
      bullet.startPosition = camera.position.clone();
      bullets.push(bullet);
      scene.add(bullet);
    });

    // Game Loop
    function animate() {
      requestAnimationFrame(animate);
      handlePlayerMovement();
      updateBullets();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>

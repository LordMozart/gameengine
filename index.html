<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D FPS Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 10px;
      height: 10px;
      background: white;
      transform: translate(-50%, -50%);
      border-radius: 50%;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <div id="crosshair"></div>
  <div id="hud">Health: <span id="playerHealth">100</span> | Score: <span id="score">0</span></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
  <script>
    // Basic setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // HUD elements
    const playerHealthElement = document.getElementById("playerHealth");
    const scoreElement = document.getElementById("score");

    // Player properties
    let playerHealth = 100;
    let score = 0;

    // Movement controls
    const keys = {};
    let isJumping = false;
    let velocityY = 0;
    const gravity = -0.01;

    document.addEventListener('keydown', (e) => keys[e.key] = true);
    document.addEventListener('keyup', (e) => keys[e.key] = false);

    const playerSpeed = 0.1;
    const jumpSpeed = 0.3;

    // Camera height (doubled)
    const cameraHeight = 2;  // Changed from 1 to 2 for 200px equivalent height
    camera.position.y = cameraHeight; // Set camera to start at the new height

    // Mouse movement to move the camera up and down (within limits)
    let verticalMovement = 0;
    let mouseYSpeed = 0.002; // Sensitivity for mouse movement

    document.addEventListener('mousemove', (event) => {
      if (document.pointerLockElement === document.body) {
        // Adjust yaw based on mouse movement for left/right rotation
        yaw -= event.movementX * 0.002;
        camera.rotation.set(verticalMovement, yaw, 0);

        // Adjust vertical camera position with mouse Y (up/down)
        verticalMovement += event.movementY * mouseYSpeed;
        verticalMovement = Math.max(-1.5, Math.min(1.5, verticalMovement)); // Restrict to vertical limits
        camera.position.y = cameraHeight + verticalMovement;
      }
    });

    // Floor setup with texture
    const floorGeometry = new THREE.PlaneGeometry(200, 200);
    const floorTexture = new THREE.TextureLoader().load('ground.jpg'); // Replace with your ground texture image
    const floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = - Math.PI / 2;
    scene.add(floor);

    // Parkour Box setup with random sizes and positions
    const parkourBoxes = [];
    const boxTexture = new THREE.TextureLoader().load('garfield.png'); // Replace with your box image

    for (let i = 0; i < 10; i++) {
      const boxGeometry = new THREE.BoxGeometry(Math.random() * 5 + 1, Math.random() * 3 + 1, Math.random() * 5 + 1); // Random size
      const boxMaterial = new THREE.MeshBasicMaterial({ map: boxTexture });
      const box = new THREE.Mesh(boxGeometry, boxMaterial);
      box.position.set(
        Math.random() * 80 - 40,
        Math.random() * 5 + 1, // Ensure they float above the ground
        Math.random() * 80 - 40
      );
      scene.add(box);
      parkourBoxes.push(box);
    }

    // Improved collision system: Raycasting for better detection
    function checkCollisions() {
      const raycaster = new THREE.Raycaster();
      const direction = new THREE.Vector3(0, -1, 0); // Ray pointing downwards for floor and box collisions
      raycaster.ray.origin.copy(camera.position);
      raycaster.ray.direction.copy(direction);

      const intersects = raycaster.intersectObjects(parkourBoxes); // Check collisions with parkour boxes
      if (intersects.length > 0) {
        // If there's a collision with a parkour box, adjust player position
        camera.position.y = intersects[0].point.y + cameraHeight; // Keep player above the box
        velocityY = 0;
        isJumping = false;
      }
    }

    // Enemy management
    const enemies = [];
    const enemySpeed = 0.05;

    function spawnEnemy() {
      const enemyGeometry = new THREE.BoxGeometry(1, 1, 1);
      const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
      enemy.position.set(
        Math.random() * 40 - 20,
        1,
        Math.random() * 40 - 20
      );
      enemy.health = 50;
      enemies.push(enemy);
      scene.add(enemy);
    }

    setInterval(spawnEnemy, 3000); // Spawn an enemy every 3 seconds

    function updateEnemies() {
      enemies.forEach((enemy, index) => {
        const direction = new THREE.Vector3();
        direction.subVectors(camera.position, enemy.position).normalize();
        enemy.position.addScaledVector(direction, enemySpeed);

        if (enemy.position.distanceTo(camera.position) < 1) {
          playerHealth -= 10;
          playerHealthElement.textContent = playerHealth;
          if (playerHealth <= 0) alert("Game Over!");
          scene.remove(enemy);
          enemies.splice(index, 1);
        }
      });
    }

    // Bullet management
    const bullets = [];
    function updateBullets() {
      bullets.forEach((bullet, index) => {
        bullet.position.add(bullet.velocity);

        // Remove bullets after 50 units or when they hit a box or enemy
        if (bullet.position.distanceTo(bullet.startPosition) > 50) {
          scene.remove(bullet);
          bullets.splice(index, 1);
        }

        // Check for collisions with parkour boxes using raycasting
        const raycaster = new THREE.Raycaster();
        raycaster.ray.origin.copy(bullet.position);
        raycaster.ray.direction.set(0, 0, 1); // Ray pointing forward

        const boxHits = raycaster.intersectObjects(parkourBoxes);
        if (boxHits.length > 0) {
          scene.remove(bullet); // Remove bullet on collision
          bullets.splice(index, 1);
        }

        // Check for collisions with enemies
        enemies.forEach((enemy, enemyIndex) => {
          if (bullet.position.distanceTo(enemy.position) < 1) {
            // Bullet hits the enemy
            enemy.health -= 25;
            if (enemy.health <= 0) {
              scene.remove(enemy);
              enemies.splice(enemyIndex, 1);
              score += 10;
              scoreElement.textContent = score;
            }
            scene.remove(bullet);
            bullets.splice(index, 1);
          }
        });
      });
    }

    // Shooting with cooldown
    let canShoot = true;

    document.addEventListener('click', () => {
      if (!canShoot) return;

      canShoot = false;
      setTimeout(() => canShoot = true, 200); // 0.2-second cooldown

      const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
      const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
      bullet.position.copy(camera.position);
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      bullet.velocity = direction.multiplyScalar(0.5);
      bullet.startPosition = camera.position.clone();
      bullets.push(bullet);
      scene.add(bullet);
    });

    // Game Loop
    function animate() {
      requestAnimationFrame(animate);
      handlePlayerMovement();
      checkCollisions();  // Perform collision check for movement
      updateEnemies();
      updateBullets();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>

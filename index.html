<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D FPS Game</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
        #health-bar, #score {
            position: absolute; color: white; font-size: 20px; padding: 10px;
        }
        #health-bar { top: 10px; left: 10px; }
        #score { top: 40px; left: 10px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="health-bar">Health: 100</div>
    <div id="score">Score: 0</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/OrbitControls.min.js"></script>
    <script>
        let scene, camera, renderer, health = 100, score = 0;
        let player, enemies = [], projectiles = [];
        let moveSpeed = 0.1, rotateSpeed = 0.01;
        let crosshair;
        let gameOver = false;

        // Initialize scene
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas') });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Ground
            let groundGeometry = new THREE.PlaneGeometry(500, 500);
            let groundMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
            let ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = Math.PI / -2;
            scene.add(ground);

            // Player
            let playerGeometry = new THREE.BoxGeometry(1, 1, 1);
            let playerMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.y = 0.5;
            scene.add(player);

            // Set camera position
            camera.position.set(0, 1, 5);

            // Crosshair
            crosshair = document.createElement('div');
            crosshair.style.position = 'absolute';
            crosshair.style.width = '20px';
            crosshair.style.height = '20px';
            crosshair.style.backgroundColor = 'red';
            crosshair.style.borderRadius = '50%';
            crosshair.style.top = '50%';
            crosshair.style.left = '50%';
            crosshair.style.transform = 'translate(-50%, -50%)';
            document.body.appendChild(crosshair);

            // Event listeners for mouse and keyboard
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onResize);

            // Spawn enemies
            spawnEnemy();

            // Start the game loop
            gameLoop();
        }

        // Game loop
        function gameLoop() {
            if (gameOver) return;
            requestAnimationFrame(gameLoop);

            // Update player movement
            if (moveForward) player.position.z -= moveSpeed;
            if (moveBackward) player.position.z += moveSpeed;
            if (moveLeft) player.position.x -= moveSpeed;
            if (moveRight) player.position.x += moveSpeed;

            // Update camera
            camera.position.set(player.position.x, player.position.y + 1, player.position.z + 5);
            camera.lookAt(player.position);

            // Check for collisions and game over conditions
            checkCollisions();

            // Render the scene
            renderer.render(scene, camera);
        }

        // Spawn enemies at random locations
        function spawnEnemy() {
            let enemyGeometry = new THREE.BoxGeometry(1, 1, 1);
            let enemyMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            let enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemy.position.set(Math.random() * 50 - 25, 0.5, Math.random() * 50 - 25);
            scene.add(enemy);
            enemies.push(enemy);
        }

        // Handle keyboard input for player movement
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        function onKeyDown(event) {
            switch (event.key) {
                case 'w': moveForward = true; break;
                case 's': moveBackward = true; break;
                case 'a': moveLeft = true; break;
                case 'd': moveRight = true; break;
            }
        }
        function onKeyUp(event) {
            switch (event.key) {
                case 'w': moveForward = false; break;
                case 's': moveBackward = false; break;
                case 'a': moveLeft = false; break;
                case 'd': moveRight = false; break;
            }
        }

        // Handle mouse movement for camera control
        let mouseX = 0, mouseY = 0;
        function onMouseMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            camera.rotation.x = mouseY * rotateSpeed;
            camera.rotation.y = mouseX * rotateSpeed;
        }

        // Handle shooting projectiles
        function onMouseDown() {
            let projectileGeometry = new THREE.SphereGeometry(0.1, 32, 32);
            let projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            let projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.set(player.position.x, player.position.y, player.position.z);
            scene.add(projectile);
            projectiles.push(projectile);

            // Simple projectile movement
            function moveProjectile() {
                projectile.position.z -= 0.5;
                if (projectile.position.z < -50) {
                    scene.remove(projectile);
                    projectiles.splice(projectiles.indexOf(projectile), 1);
                }
            }

            moveProjectile();
        }

        // Collision detection
        function checkCollisions() {
            projectiles.forEach((projectile, index) => {
                enemies.forEach((enemy, enemyIndex) => {
                    if (projectile.position.distanceTo(enemy.position) < 1) {
                        score += 10;
                        document.getElementById('score').innerText = `Score: ${score}`;
                        scene.remove(enemy);
                        enemies.splice(enemyIndex, 1);
                    }
                });
            });
        }

        // Resize event
        function onResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }

        // Initialize the game
        init();
    </script>
</body>
</html>
